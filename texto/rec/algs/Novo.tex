\begin{algorithm}
	\caption{\Novo\ -- \fACMP\ usando as novas estruturas}
	\label{alg:novo}
	
	\newcommand \imgN {E}
	
	\Entrada{Dois nós $a$ e $b$ \newline
	         %Opa \newline
	         Uma função \bpn, que retorna o nível
	          do ancestral comum entre dois nós
	          dado um número com apenas um bit 1,
	          na primeira posição em que o ID dos nós difere \newline
	         A função \textsc{Espalhamento} (Algoritmo \ref{alg:espalha})
	          com dados da árvore em questão \newline
	         Uma matriz (vetor de vetores) $\imgN$,
	          onde o vetor $\imgN(i)$ possui os nós do nível $i$
	          distribuídos pela função \textsc{Espalhamento}($i$, id)}
	\Saida{O ACMP entre $a$ e $b$}
	\BlankLine
	
	%Nota: Processadores atuais possuem uma instrução cujo resultado
	%      é a posição do primeiro bit 1 em um número,
	%      o qual pode ser usado para acessar um arranjo
	%\BlankLine
	
	\LinesNumbered
	%\Function{ancestral}{Estruturas $\var{E}$, No $a$, No $b$}
	%ID dif, bit, \var{masc}, id;
	\tcp{Bits que diferem}
	$\var{dif} \gets \id{a} \OuExBit \id{b}$ \\
	\tcp{Bit 1 apenas na primeira posição em que os IDs diferem}
	$\var{bit} \gets \var{dif} \EBit (-\var{dif})$ \\
	\tcp{Todos os bits antes do primeiro diferente}
	$\var{\var{masc}} \gets \var{bit} - 1$ \\
	%//\var{masc} = (((\var{dif}-1) ^ \var{dif}) >> 1);
	\tcp{Id do ancestral comum mais próximo}
	$\var{id} \gets \id{a} \EBit \var{masc}$ \\
	
	\BlankLine
	\tcp{Encontra o nó}
	$\var{nível} \gets \bpn(\var{bit})$ \\
	$\var{pos}   \gets \textsc{Espalhamento}(\var{nível}, \var{id})$ \\
	\Retorna $\imgN(\var{nível}, \var{pos})$ \\
	
	%\tcp{Arranjo com os nós já distribuídos pela função de espalhamento}
	%$\var{imagemNivel} \gets \mathrm{E.imagemNiveis}(nivel)$ \\
	%$\var{imagemNó} \gets
	%	\mathrm{E.dadosFuncao}[\var{nivel}].aplicar(\var{id})$ \\
	%\Retorna $\var{imagemNivel}[\var{imagemNó}]$ \\
\end{algorithm}

% Espalhamento
\begin{algorithm}
	\caption{\Espalha\ -- Função de espalhamento}
	\label{alg:espalha}
	
	\Entrada{Um nível $n$ ($n \in \mathbb{Z}$, $n \ge 0$) \newline
	         O id de um nó}
	\Saida{A posição em que o nó deve ficar no vetor do seu nível}
	\BlankLine
	
	\SetKwInput{Nota}{Nota}
	
	\Nota {Os valores $\var{ad}_{n}$, $\var{m}_{n}$,
	                 $\var{mult}_{n}$ e $\var{desl}_{n}$
	        dependem da árvore com a qual se usará esta função
	        e do nível recebido ($n$). \newline
	       $x \Desl b$ é o valor $x$ deslocado $b$ bits para a direita,
	       equivalente a $\lfloor x/(2^b)\rfloor$.}
	\BlankLine
	
	\tcp{Minimiza o maior resultado ${}\bmod m_{n}$
	     para minimizar o tamanho do vetor}
	$\var{v} \gets \var{id} + \var{ad}_{n}$ \\
	\tcp{Equivalente a $\var{v} \bmod m_{n}$}
	\Retorna $\var{v} - ((\var{v} * \var{mult}_{n})
		\Desl \var{desl}_{n}) * m_{n}$ \\
\end{algorithm}
