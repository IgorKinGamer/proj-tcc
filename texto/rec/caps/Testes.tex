% Seção sobre testes de desempenho

\chapter{Testes de desempenho}
%POR QUÊ

Com o objetivo de avaliar o desempenho do algoritmo desenvolvido, foram realizados testes
que permitiram comparar o desempenho das diferentes abordagens.
Foi medido o tempo tomado pelos algoritmos
ao se encontrar repetidamente o ACMP entre os nós folhas de uma árvore.
Com esses dados, analisados

Um programa foi desenvolvido, também na linguagem C++, para realizar os testes de desempenho.
Foi utilizada a funcionalidade de templates da linguagem para facilitar a definição equivalente dos testes para todos os algoritmos, mas ainda assim permitir que o compilador otimizasse as chamadas, evitando custos adicionais durante os testes devido à hierarquia de classes utilizada.
O programa depende da biblioteca do hwloc.
Os valores medidos são escritos em um arquivo no formato CSV (Valores Separados por Vírgula -- \textit{Comma-Separated Values})


\section{Máquinas utilizadas nos testes}

Os testes foram executados sobre duas máquinas (notebooks), que serão identificadas como Máquina A e Máquina B, para as quais o programa lstopo gera as representações de hierarquia apresentadas na Figura \ref{img:maquinas}. Estas representações revelam o tamanho das memórias cache, que podem ter efeito nos resultados dos testes. Ambas possuem o sistema operacional Windows 10. \tratar{Mais detalhes (processador)?}

\begin{figure}
	\centering
	\caption{Saída do programa lstopo sobre as máquinas utilizadas}
	\label{img:maquinas}
	\begin{subfigure}{.4\textwidth}
		\caption{Máquina A}
		\includegraphics[width=\textwidth]{rec/img/MaqA}
	\end{subfigure}
	~
	\begin{subfigure}{.4\textwidth}
		\caption{Máquina B}
		\includegraphics[width=\textwidth]{rec/img/MaqB}
	\end{subfigure}

\end{figure}

%COMO
\section{Estrutura dos testes}

Os testes consistem em encontrar repetidamente o ACMP entre os nós folhas de uma dada árvore com os diferentes algoritmos -- o existente no hwloc e os implementados.
Cada vez que as estruturas necessárias são criadas e os testes são executados sobre elas com um determinado algoritmo, obtém-se uma observação, que é o tempo que levou para realizar a quantidade especificada de repetições da função ACMP entre os nós folhas da árvore com o algoritmo.

Para cada algoritmo, uma árvore de estrutura equivalente é criada (as estruturas de dados dependem do algoritmo) a partir dos graus fornecidos como entrada.
%(Como os graus são usados para montar a árvore -- se não for explicado antes)
Os graus são recebidos como uma lista de inteiros positivos.
O i-ésimo será o grau do nível $i-1$.
Deste modo, se os graus recebidos são $(g_1, g_2, ..., g_n)$, a raiz terá $g_1$ filhos, cada um com $g_2$ filhos, e assim por diante, até os nós do nível $n-1$, que terão $g_n$ filhos cada.

Para obter uma observação de um algoritmo, uma lista contendo todos os pares possíveis de nós folhas (todas as combinações de duas folhas) é criada.
Esta lista é embaralhada, usando uma semente fixa, de modo que a ordem pseudo-aleatória é a mesma para todas as execuções de todos os algoritmos sobre esta árvore.

Uma observação é obtida por meio de uma etapa de aquecimento seguida de uma de medição, na qual o tempo total das repetições da função ACMP é medido.
Ambas as etapas consistem em algum número de rodadas, o qual geralmente deve estar na casa de alguns milhares, dependendo do tamanho da árvore, para que o tempo medido seja significativo.
Em cada rodada, a lista previamente embaralhada de pares de folhas é varrida e, para cada par, o ACMP é encontrado usando o algoritmo em questão.

As observações dos diferentes algoritmos são realizadas de forma intercalada.
O número de observações obtidas para cada algoritmo em uma execução do programa depende de dois parâmetros, número de iterações externas e de iterações internas.
O número de iterações internas é a quantidade de observações que serão obtidas para um dos algoritmos antes de passar para outro.
A execução da quantidade de iterações internas para cada algorimo compõe uma iteração externa.
Esta forma de especificar a quantidade de observações originou-se nas etapas iniciais dos testes, para facilitar a visualização dos resultados, mas foi mantida.
No entanto, julga-se melhor usar poucas iterações internas e mais externas para evitar que eventuais condições temporárias da máquina, causadas por elementos externos ao programa, afetem diversas observações de apenas um dos algoritmos.

O programa também permite escolher quais algoritmos serão testados.
Os possíveis são o simples, o que utiliza as novas estruturas, o que utiliza uma matriz e o implementado no hwloc.

%(Tabela com os parâmetros?)


\subsection{RESULTADOS}

As árvores utilizadas nos testes correspondem à hierarquia de memória de máquinas reais, apresentadas no site do projeto hwloc, como representadas pelo programa lstopo \cite{lstopo}.
Assim, os resultados refletem a diferença dos algoritmos quando operando sobre hierarquias reais.
%\tratar{(Referência: The Best of lstopo - https://www.open-mpi.org/projects/hwloc/lstopo/)}

\tratar{especificar parâmetros utilizados}

Inicialmente, os testes foram feitos sem acessar o ACMP obtido a cada execução, ou seja, para cada par de folhas, simplesmente se encontrava o ponteiro para o ancestral, mas nenhum dado do ancestral era obtido.
%(apenas era feito algo com o ponteiro retornado para evitar otimizações que descartassem tudo devido ao resultado não ser usado).
No entanto, em cenários reais, os nós seriam buscados para se obter alguma informação sobre eles, portanto, foi adicionado um acesso a um valor qualquer de cada ACMP encontrado para simular isso.
A Figura \ref{fig:box_sem_com} compara o desempenho dos quatro algoritmos na Máquina A para a árvore com os graus $(1, 4, 1, 1, 9, 2, 1, 1, 4)$ antes e depois do acréscimo desse acesso.
Sem o acesso foram feitas 300 observações de cada algoritmo e, com o acesso, 150 observações.
Como era esperado, os tempos aumentaram para todos os algoritmos, porém o algoritmo menos afetado foi o novo e o mais afetado foi o da matriz, considerando a porcentagem de aumento do valor mediano após acrescentar o acesso, conforme a Tabela \ref{tab:aumento_mediana}.

\begin{figure}
	\caption{Tempos com e sem acesso ao ACMP}
	\label{fig:box_sem_com}
	\resizebox{\textwidth}{!}{\input{rec/img/opa}}
\end{figure}

\begin{table}[htb]
	\IBGEtab{\caption{Aumento (\%) do tempo mediano}%
		\label{tab:aumento_mediana}}
	{\begin{tabular}{cccc}
		\toprule
		Simples & Novo & hwloc & Matriz \\
		\midrule 
		14,04 & 10,08 & 14,92 & 27,93 \\
		\bottomrule
	\end{tabular}}{}%  \fonte{Produzido pelos autores.}%
\end{table}

%Comparação - O desempenho do algoritmo desenvolvido foi comparado com o do algoritmo simples, o do hwloc (e o que usa a matriz)(?)

%Outras medições?

\tratar{Outras análises: comparações entre as máquinas, comparar tempo médio por acesso do novo algoritmo entre topologias de tamanhos diferentes}
