% Seção sobre testes de desempenho

\chapter{Testes de desempenho}
%POR QUÊ

Com o objetivo de avaliar o desempenho do algoritmo desenvolvido, foram realizados testes
que permitiram comparar o desempenho das diferentes abordagens.
Foi medido o tempo tomado pelos algoritmos
ao se encontrar repetidamente o ACMP entre os nós folhas de uma árvore.
Com esses dados, analisados

Um programa foi desenvolvido, também na linguagem C++, para realizar os testes de desempenho.
Foi utilizada a funcionalidade de templates da linguagem para facilitar a definição equivalente dos testes para todos os algoritmos, mas ainda assim permitir que o compilador otimizasse as chamadas, evitando custos adicionais durante os testes devido à hierarquia de classes utilizada.
O programa depende da biblioteca do hwloc.
Os valores medidos são escritos em um arquivo no formato CSV (Valores Separados por Vírgula -- {\it Comma-Separated Values})

%COMO
\section{Estrutura dos testes}

Os testes consistem em encontrar repetidamente o ACMP entre os nós folhas de uma dada árvore com os diferentes algoritmos -- o existente no hwloc e os implementados.
Cada vez que as estruturas necessárias são criadas e os testes são executados sobre elas com um determinado algoritmo, obtém-se uma observação, que é o tempo que levou para realizar a quantidade especificada de repetições da função ACMP entre os nós folhas da árvore com o algoritmo.

Para cada algoritmo, uma árvore de estrutura equivalente é criada (as estruturas de dados dependem do algoritmo) a partir dos graus fornecidos como entrada.
%(Como os graus são usados para montar a árvore -- se não for explicado antes)
Os graus são recebidos como uma lista de inteiros positivos.
O i-ésimo será o grau do nível $i-1$.
Deste modo, se os graus recebidos são $(g_1, g_2, ..., g_n)$, a raiz terá $g_1$ filhos, cada um com $g_2$ filhos, e assim por diante, até os nós do nível $n-1$, que terão $g_n$ filhos cada.

Para obter uma observação de um algoritmo, uma lista contendo todos os pares possíveis de nós folhas (todas as combinações de duas folhas) é criada.
Esta lista é embaralhada, usando uma semente fixa, de modo que a ordem pseudo-aleatória é a mesma para todas as execuções de todos os algoritmos sobre esta árvore.

Uma observação é obtida por meio de uma etapa de aquecimento seguida de uma de medição, na qual o tempo total das repetições da função ACMP é medido.
Ambas as etapas consistem em algum número de rodadas, o qual geralmente deve estar na casa de alguns milhares, dependendo do tamanho da árvore, para que o tempo medido seja significativo.
Em cada rodada, a lista previamente embaralhada de pares de folhas é varrida e, para cada par, o ACMP é encontrado usando o algoritmo em questão.

As observações dos diferentes algoritmos são realizadas de forma intercalada.
O número de observações obtidas para cada algoritmo em uma execução do programa depende de dois parâmetros, número de iterações externas e de iterações internas.
O número de iterações internas é a quantidade de observações que serão obtidas para um dos algoritmos antes de passar para outro.
A execução da quantidade de iterações internas para cada algorimo compõe uma iteração externa.
Esta forma de especificar a quantidade de observações originou-se nas etapas iniciais dos testes, para facilitar a visualização dos resultados, mas foi mantida.
No entanto, julga-se melhor usar poucas iterações internas e mais externas para evitar que eventuais condições temporárias da máquina, causadas por elementos externos ao programa, afetem diversas observações de apenas um dos algoritmos.

O programa também permite escolher quais algoritmos serão testados.
Os possíveis são o simples, o que utiliza as novas estruturas, o que utiliza uma matriz e o implementado no hwloc.

(Tabela com os parâmetros?)


(Os resultados de testes feitos indicaram que a operação mais custosa no novo método era o módulo.
No entanto, 
Divisão com denominador previamente conhecido [referência]
Não em tempo de compilação, mas quando se está montando as estruturas.
Portanto, é possível substituir essa operação de módulo por outras operações mais baratas, a saber, duas multiplicações, um deslocamento e uma subtração.
Com esta alteração, os tempos diminuiram consideravelmente, conforme mostra a tabela [X])


\subsection{RESULTADOS}

Inicialmente, os testes foram feitos sem acessar o ACMP obtido a cada execução, ou seja, para cada par de folhas, simplesmente se encontrava o ponteiro para o ancestral, mas nenhum dado do ancestral era obtido (apenas era feito algo com o ponteiro retornado para evitar otimizações que descartassem tudo devido ao resultado não ser usado).
Nessas condições e na máquina A, os resultados apresentados (na tabela [X]) foram obtidos.

Comparação - O desempenho do algoritmo desenvolvido foi comparado com o do algoritmo simples, o do hwloc (e o que usa a matriz)(?)

As árvores utilizadas nos testes correspondem à hierarquia de memória de máquinas reais, apresentadas no site do projeto hwloc, como representadas pelo programa lstopo.
Assim, os resultados refletem a diferença dos algoritmos quando operando sobre hierarquias reais.
(Referência: The Best of lstopo - https://www.open-mpi.org/projects/hwloc/lstopo/)

Outras medições?
