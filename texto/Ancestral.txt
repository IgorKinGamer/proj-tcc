Motivação

(Analisei hwloc
Vi complexidade das funções
Em geral O(1) ou O(altura)
Uso no HieSchella)

Conceitos:
- Grau de um nível: o maior entre os graus dos nós de um nível.
É comum todos os graus dos nós de um nível serem iguais, mas, em hierarquias assimétricas, isso não ocorre.

O hwloc possui diversas funções de percorrimento.
Estas permitem acessar nós da árvore que representa a hierarquia de forma absoluta ou relativa a outros nós.
Por exemplo, é possível encontrar o nó com um determinado índice dentro de um dado nível,
ou, a partir de algum nó, o próximo no mesmo nível.
Essas funções foram analisadas quanto à complexidade com o objetivo de identificar pontos que poderiam ser melhorados do ponto de vista do desempenho.
Essa análise revelou que, em geral, elas têm tempo constante (O(1)) ou linear na altura da árvore (O(altura)).
. [(Nota?) Em análises de complexidade, a altura de uma árvore é comumente associada com log N, onde N é o número de nós.
. Entretanto, isso é válido para árvores com o mesmo grau em todos os níveis.
. Em árvores que representam hierarquias, os níveis podem ter graus diferentes, logo, essa associação não é possível.]
Além disso, foi analisado um projeto de código aberto que utiliza o hwloc, HieSchella [ref],
cujo objetivo é prover portabilidade de performance, característica presente quando se consegue que
uma mesma aplicação rode em diferentes plataformas utilizando os núcleos com eficiência.
Foram identificadas as chamadas mais importantes a funções do hwloc no HieSchella para se ter uma referência
de quais funções são mais relevantes para o desempenho dentro de um projeto real.

identificado que ela é uma

Diante dessas considerações, a função que encontra o ancestral comum mais próximo entre dois nós foi escolhida como alvo de otimizações.
Ela é uma das funções implementadas no hwloc com complexidade O(altura) e está entre as de uso mais significativo no HieSchella.
Na seção a seguir, será discutido como essa função poderia ser implementada de forma mais eficiente e quais as implicações de diferentes abordagens.


SEÇÂO

 um método 

A função que encontra o ancestral comum mais próximo recebe dois nós como entrada (e possivelmente algumas estruturas adicionais, se houver necessidade)
e retorna um nó (o ancestral) como saída.
Cada par de nós em uma árvore tem exatamente um ancestral comum mais próximo.

(Definir ancestral e descendente?)

Abordagem simples - complexidade - questões relacionadas à memória
A maneira provavelmente mais intuitiva para se descobrir o ACMP é "subir" pela árvore, isto é.
No entanto, é necessário 
Por ser uma , será referida como método simples.
O(altura) - A altura geralmente não deve ser muito grande
Tratamento de hierarquias assimétricas

Considerando a estrutura de árvore apenas, a única informação que relaciona um nó aos seus ancestrais
são as ligações entre um nó e seus filhos (ou, no outro sentido, entre cada nó e seu pai).
Todas as sequências de uma ou mais ligações de filho para pai a partir de um nó (ou seja,
entre o nó e seu pai, entre este e o pai dele, e assim por diante) definem os ancestrais do nó.
Isso indica que outras estruturas associadas aos nós ou à árvore como um todo se fazem necessárias
para ser possível encontrar o ACMP com algum método além do simples.
Podemos considerar a seguinte ideia para encontrar outra maneira de implementar a função de ancestral comum:
Para uma dada árvore, que representa uma topologia:
- Atribuir um valor (chamado de ID) a cada nó da árvore
- Definir uma função ACMP_{IDs} que receba o ID de dois nós distintos e tenha como resultado o nó ancestral comum mais próximo.
Esses IDs (em conjunto com outras informações associadas a cada nó individualmente ou à árvore como um todo conforme necessário)
podem estabelecer alguma relação entre um nó e seus ancestrais além da que já existe por meio das ligações da árvore.

Idealmente, essa função deveria ser *processada* em tempo constante.
Ou seja, é necessário encontrar um algoritmo que seja executado em tempo constante nos processadores modernos.
No entanto, é preciso lembrar que, mesmo que a quantidade de instruções executadas pelo processador seja constante,
a maneira como a memória é acessada pode aumentar o tempo de execução, especialmente quando há outras tarefas fazendo uso da memória, o que deve acontecer em cenários reais.
(? Isso pode ser visto... (exemplo à frente com matriz?))

Com isso em mente, podemos definir tal função usando as operações básicas encontradas no conjunto de instruções das arquiteturas atuais,
tais como as operações aritméticas e operações lógicas bit-a-bit.

Uma possibilidade é relacionar cada par de nós ao seu ACMP por meio de uma matriz
em que cada linha representa um nó da árvore, assim como cada coluna, e o cruzamento contém o ACMP entre o nó da linha e o nó da coluna.
Para isso, pode-se atribuir a cada um dos n nós da árvore um ID único entre 0 e n-1 e usar esses IDs como índices na matriz,
que terá, na posição A(i,j), o ACMP entre o nó de ID i e o nó de ID j.
No entanto, esta é uma estratégia ingênua, pois esse espaço O(n^2) ocupado na memória resultaria em problemas como sujar a cache da aplicação.

Outra possibilidade foi idealizada, dividindo a função ACMP_{IDs} em dois passos:
- dados os IDs de dois nós, descobrir o ID do ancestral,
- encontrar o nó que possui esse ID.
Em linhas gerais, o funcionamento se baseia no seguinte:
- O comprimento de um ID é a quantidade de bits da sua representação em binário, descartando zeros à esquerda.
- O ID de um nó é mais comprido que o de todos os nós de todos os níveis acima
- O ID de um nó é formado por um ou mais bits seguidos do ID do seu pai, de modo que, dados dois nós a e b, b descendente de a,
os n bits menos significativos de b são iguais ao ID de a, onde n é o comprimento do ID de a.
- Desse modo, dados dois descendentes de um nó c, todos os bits menos significativos deles que coincidem
(todos os que vêm antes do primeiro que difere) são iguais ao ID de c (ignorando zeros à esquerda).
- Usando apenas as operações ???,
para as quais existem instruções que tomam poucos ciclos nas arquiteturas atuais,
pode-se descobrir o ID do ancestral comum
- A quantidade de instruções é fixa, portanto, a complexidade é constante

Encontrar o nó a partir do ID
- Usar os IDs como índices em um arranjo seria simples, mas impraticável:
poderiam ser necessários arranjos com milhões de posições e apenas algumas centenas ocupadas.
- Usar uma função de espalhamento (hash): podem haver colisões
- Buscar uma função que não cause colisões

Detalhes de como os IDs são formados
Função (algoritmo) em si
Pode falhar se os dois nós de entrada são, na verdade, o mesmo nó. If resolve

Medições de tempo (repetições):
Resultados, comparação
O novo método se mostrou, em geral, mais demorado que o método simples, mas mais rápido que o hwloc.
No entanto, ele funciona em casos de hierarquias assimétricas, assim como o hwloc, diferentemente do método simples.

Outras medições?

Culpado é o módulo! Módulo sem divisões.


#######

Código em C++
Testes usando templates, o que permite a otimização das chamadas para não afetarem as medições com indireções.


#######

Melhorias e alternativas não testadas:
- Eliminar multiplicações (mas testes feitos mostram que não têm grande custo)
- Todos os nós em um só arranjo
- Máscaras Ou e OuExclusivo
