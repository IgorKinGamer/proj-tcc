#ifndef ARV_H
#define ARV_H

#include <iostream>
#include <bitset>
#include <climits>

#include <algorithm>

#include "defs.h"
#include "arv_mod.h"

using namespace std;

struct No
{
	// Id usado para encontrar ancestral mais próximo
	ID id;
	
	No *pai;
	unsigned numFilhos;
	No **filhos;
	
	// Nível do nó: 0 -> raiz
	unsigned nivel;
	
	void imprimir() { imprimir(0); }
	
	friend inline ostream& operator<<(ostream &o, const No* n) { o << n->id; return o; } // !!!
	
	void imprimir(int ind)
	{
		for (int i = 0; i < ind; i++)
			cout << '|'; // Indentação
		cout << "No " << bitset<sizeof(id)*CHAR_BIT>(id) << " (" << nivel << ' ' << numFilhos << ')' << endl;
		++ind;
		for (int f = 0; f < numFilhos; f++)
			filhos[f]->imprimir(ind);
	}
	
	// TODO Destrutor
};

class Arvore
{
	public:
	No *raiz;
	
	// Quantidade de níveis
	unsigned numNiveis;
	// Arranjos por nível com nós na posição resultante
	No ***imagemNiveis;
	// NOTA: Níveis cujos nós têm um só filho poderiam ser totalmente
	// omitidos na busca do ancestral mais próximo, desde o bit ocupado
	// desnecessariamente no id até as estruturas (pois não são ancestral
	// mais próximo de nenhum par de nós distintos), mas isso exigiria um
	// tratamento todo especial...
	// A não ser que os nós tenham um No **filhosEspecial.
	
	// nivelDosBits[i]: Nível do ancestral mais próximo de a e b quando
	// o primeiro bit que difere entre a->id e b->id é i
	unsigned *nivelDosBits;
	
	// Módulo usado para cada nível da árvore
	// Folhas não precisam
	DadosFuncao *dadosFuncao;
	
	Arvore(No* r, unsigned nNiveis)
	{
		raiz = r;
		numNiveis = nNiveis;
		dadosFuncao = new DadosFuncao[numNiveis];
	}
	
	~Arvore()
	{
		for (unsigned i = 0; i < numNiveis-1; i++)
			delete imagemNiveis[i];
		delete imagemNiveis;
		delete raiz;
		delete dadosFuncao;
	}
	
	// Descobrir quantos nós por nível
	// Descobrir quantos níveis são realmente necessários
	// Pegar todos os nós de um nível em um array e descobrir o m
	
	unsigned bitParaNivel(ID bit)
	{
		unsigned pos = __builtin_ctz(bit); // Primeiro bit 1
		return nivelDosBits[pos];
	}
	
	void montarEstruturas()
	{
		// Descobre quantos nós há em cada nivel e o grau máximo
		unsigned *nosPorNivel = new unsigned[numNiveis] (); // Inicia com 0
		unsigned *grauPorNivel = new unsigned[numNiveis] (); // Inicia com 0
		preencherNosGrauPorNivel(nosPorNivel, grauPorNivel, raiz);
		
		// Preenche mapeamento (primeiro bit diferente -> nivel do ancestral)
		// Se os graus (da raiz, filhos e netos) são [2, 3, 3]: [0, 0, 1, 1, 1, 2, 2, 2]
		unsigned *grau = grauPorNivel, somaGraus = 0;
		while (*grau != 0)
			somaGraus += *(grau++);
		cout << "Somatório dos graus: " << somaGraus << '\n';
		nivelDosBits = new unsigned[somaGraus];
		unsigned *bit = nivelDosBits, nivelAnc = 0;
		while (grau[nivelAnc] != 0)
		{
			for (unsigned i = 0; i < grau[nivelAnc]; i++)
				*(bit++) = nivelAnc;
			nivelAnc++;
		}
		
		// Se os nós ainda não têm ids, atribuir aqui... (agora têm-se os graus)
		// (Árvores geradas com construirArvore() já têm os ids)
		// TODO
		
		// Cria um arranjo por nível com os ids e outro com os nós
		// do nivel para descobrir os módulos e distribuir os nós
		No** nosNiveis[numNiveis];
		ID* idsNiveis[numNiveis];
		for (unsigned nivel = 0; nivel < numNiveis; nivel++)
		{
			nosNiveis[nivel] = new No*[nosPorNivel[nivel]];
			idsNiveis[nivel] = new ID[nosPorNivel[nivel]];
		}
		// Próxima posição a preencher de cada nível
		unsigned *proxPos = new unsigned[numNiveis] (); // Zerado
		// Pega os ids
		preencherNosIdsNiveis(nosNiveis, idsNiveis, proxPos, raiz);
		// !!! Mostra ids
		/*for (int i = 0; i < numNiveis; i++)
		{
			for (int j = 0; j < nosPorNivel[i]; j++)
				cout << bitset<sizeof(ID)*CHAR_BIT>(idsNiveis[i][j]) << '\n';
			cout << '\n';
		}*/
		
		// Descobrir o módulo para cada nível (menos último nível)
		imagemNiveis = new No**[numNiveis-1];
		imagemNiveis[0] = 0;
		for (unsigned nivel = 0; nivel < numNiveis-1; nivel++)
		{
			unsigned numNos = nosPorNivel[nivel];
			No **nos = nosNiveis[nivel];
			ID *ids = idsNiveis[nivel];
			DadosFuncao *dadosNivel = &dadosFuncao[nivel];
			// Encontra valores para a função que distribui os nós
			buscarFuncaoIdeal(numNos, ids, dadosNivel);
			// Coloca os nós nas posições resultantes da função
			No **imagemNivel = new No*[dadosNivel->tam] (); // Zerado
			for (unsigned no = 0; no < numNos; no++)
				imagemNivel[dadosNivel->aplicar(ids[no])] = nos[no];
			imagemNiveis[nivel] = imagemNivel;
		}
		
		// Libera
		delete nosPorNivel;
		for (unsigned nivel = 0; nivel < numNiveis; nivel++)
		{
			delete nosNiveis[nivel];
			delete idsNiveis[nivel];
		}
		delete proxPos;
	}
	
	void preencherNosGrauPorNivel(unsigned *nosPorNivel, unsigned *grauPorNivel, No *no)
	{
		++nosPorNivel[no->nivel];
		grauPorNivel[no->nivel] = std::max(grauPorNivel[no->nivel], no->numFilhos);
		for (int i = 0; i < no->numFilhos; i++)
			preencherNosGrauPorNivel(nosPorNivel, grauPorNivel, no->filhos[i]);
	}
	
	void preencherNosIdsNiveis(No ***nosNiveis, ID **idsNiveis, unsigned *proxPos, No *no)
	{
		// Coloca nó e id na próxima posição da linha do nível do nó
		nosNiveis[no->nivel][proxPos[no->nivel]  ] = no;
		idsNiveis[no->nivel][proxPos[no->nivel]++] = no->id;
		for (unsigned i = 0; i < no->numFilhos; i++)
			preencherNosIdsNiveis(nosNiveis, idsNiveis, proxPos, no->filhos[i]);
	}
};

#endif /* ARV_H */
